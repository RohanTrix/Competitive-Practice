/**
 *      IDEA : Solved by Self :)
 *             We first make a adj list to make things easier and more optimal than a adj matrix.
 *             Also sort the initial array to get lowest node val as ans.
 *             Now, the idea is to go thru each node in `inital`...and set up a dsu excluding the curr node from initial.
 *             This will easily make components that will be split by removing current node. Now, we just traverse over all nodes in intial
 *             (except the current node temporarily removed from the edges) and check which set they belong to. We want to add the rank of this
 *             set to our cnt. We will skip a set if it has already been added once(case when 2 or more infected nodes lie in same set).
 *             FINALLY WE WANT TO MINIMISE cnt. 
 */

public class Minimize_Malware_Spread_II {
    private class DSU
    {
        int parent[], rank[];
        public DSU(int n)
        {
            parent = new int[n];
            rank = new int[n];
            Arrays.fill(parent, -1);
            Arrays.fill(rank, 1);
        }
        public int find(int u)
        {
            if(parent[u] == -1) return u;
            return parent[u] = find(parent[u]);
        }
        public void union(int a, int b)
        {
            int s1 = find(a);
            int s2 = find(b);
            if(s1!=s2)
            {
                if(rank[s1]>rank[s2])
                {
                    rank[s1]+=rank[s2];
                    parent[s2] = s1;
                }
                else
                {
                    rank[s2]+=rank[s1];
                    parent[s1] = s2;
                }
            }
        }
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Map<Integer, Set<Integer>> edges = new HashMap<>();
        Arrays.sort(initial);
        int n = graph.length;
        for(int i = 0; i<n; i++)
            edges.put(i, new HashSet<>());
        for(int i = 0; i<n; i++)
            for(int j = i+1; j<n; j++)
                if(graph[i][j] == 1)
                {
                    edges.get(i).add(j);
                    edges.get(j).add(i);
                }
        int cnt = 0;
        int bestNode = -1, bestM = Integer.MAX_VALUE/2;
        for(int node : initial)
        {

            DSU d = new DSU(n);
            for(int from : edges.keySet())
                for(int to : edges.get(from))
                {
                    if(from == node || to == node) continue;
                        d.union(from, to);
                }
            cnt = 0;
            Set<Integer> visited = new HashSet<>();
            for(int infected : initial)
            {
                if(infected == node) continue;
                int set = d.find(infected);
                if(visited.contains(set)) continue;
                cnt+=d.rank[set];
                visited.add(set);
            }
            if(cnt<bestM)
            {
                bestNode = node;
                bestM = cnt;
            }
        }
        return bestNode;
    }
}
