/*
    IDEA :
        First we sort the initial array. We use DSU to build up connected components.
        Now, we also create a map that stores how many infected node does each component contains

        The idea is...if a connected component has only one infected node, then this can be saved to save the entire connected component.
        If a connected component has more than 1 infected nodes, it is impossble to save any node in that component.

        Now, for components having only one infected node, we want the size of the component to be MAX. That is where DSU's rank array's help.
        
        So we basically go for every infected node, check if it's set has only one infected node...and update our answer if the set it belongs
        to is higher than current max set size

*/
public class Minimize_Malware_Spread {
    static class DSU
    {
        public int parent[];
        public int rank[];
        public DSU(int num)
        {
            parent = new int[num];
            rank = new int[num];
            Arrays.fill(rank,1);
            Arrays.fill(parent,-1);
        }
        public int find( int i)
        {
            if(parent[i]== -1)
                return i;
            return parent[i] = find(parent[i]); 
        }
        public boolean union(int a, int b)
        {
            int s1 = find(a);
            int s2 = find(b);
            if( s1!= s2)
            {
                if( rank[s1] < rank[s2] )
                {
                    parent[s1] = s2;
                    rank[s2] += rank[s1];
                }
                else
                {
                    parent[s2] = s1;
                    rank[s1] += rank[s2]; 
                }
                return true;
            }
            return false;
        }
    }
    
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        int n = graph.length;
        DSU d = new DSU(n);
        
        for(int i = 0; i<n; i++)
            for(int j = i+1; j<n; j++)
                if(graph[i][j] == 1)
                    d.union(i,j);
        
        
        Map<Integer, Integer> countInfected = new HashMap<>();
        for(int num : initial)
            countInfected.put(d.find(num), countInfected.getOrDefault(d.find(num),0)+1);
        
        int ans = initial[0];
        int maxi = 0;
        for(int infectedNode : initial)
        {
            int leader = d.find(infectedNode);
            if(countInfected.get(leader)==1 && maxi<d.rank[leader])
            {
                maxi = d.rank[leader];
                ans = infectedNode;
            }
        }
        return ans;
    }
}
